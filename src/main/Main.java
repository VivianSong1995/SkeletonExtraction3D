package main;

import java.io.FileNotFoundException;
import java.util.Vector;

import skeleton.Bone;
import skeleton.Chain;
import skeleton.Node;
import skeleton.SkeletonExtraction;
import skeleton.SkeletonRefine;
import skeleton.SkeletonSystemGeneration;

import math.Ray;
import math.Triangle;
import math.geom3d.Point3D;
import math.geom3d.Vector3D;

import export.Load3D;
import gui.InfoScreen;
import gui.MainWindow;

/**
 * This is the main class
 * 
 * @author Jim Stanev
 */
public class Main {

	/**
	 * width, height of the window
	 */
	public static int WIDTH = 700, HEIGHT = 700;
	/**
	 * obj 3D loader
	 */
	private static Load3D obj3D;
	/**
	 * faces of the model
	 */
	public static Vector<Triangle> faces;
	/**
	 * vertices of the model
	 */
	public static Vector<Node> vertices;
	/**
	 * chains generated by skeleton extraction
	 */
	public static Vector<Chain> chains;
	/**
	 * root of the bone system
	 */
	public static Bone root;
	
	/**
	 * the amaund of pushing toward the inner of the model,
	 * used in skeleton extraction by pushInside()
	 */
	public static int PUSHING_FACTOR = 1;
	/**
	 * the number of iterations used for finding the local
	 * minimum of a point, used in skeleton extraction by
	 * localeMinimum()
	 */
	public static int ITERATIONS = 40;
	/**
	 * the number of steps for calculating the new position
	 * of vrf vector in skeleton extraction by vrf()
	 */
	public static int STEP = 10;
	/**
	 * the number of jumps used to rarefy the number of nodes
	 * in a chain, used in skeleton refine by sampling()
	 */
	public static int SAMPLING = 10;
	/**
	 * used for filtering the local minimum convergence, used 
	 * in skeleton refine by sampling()
	 */
	public static double DISTANCE_TOLERANCE = 2;
	/**
	 * used for merging the last nodes of a chain in skeleton
	 * refine by mergeNodes()
	 */
	public static double MERGE_TOLERANCE = 5;
	/**
	 * used for pruning the small chains by setting a threshold
	 * of the size of a chain, used in skeleton refine by pruning()
	 */
	public static int CHAIN_SIZE_TOLERANCE = 2;
	/**
	 * indicates the number of attached bones in a node used for
	 * skinning and calculating the weights
	 * 
	 * Linear blend skinning: v' = Ó(wi*Mi*Bi*v)
	 */
	public static int SKIN_DEPENDENCIES = 2;
	
	/**
	 * printing pattern
	 */
	public static final String PRINT_SEP = "#################################";
	
	/**
	 * Main
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		
		//info screen
		InfoScreen infoScreen = new InfoScreen();
		infoScreen.setVisible(true);
		
		//main window
		MainWindow mainWindow = new MainWindow();
		mainWindow.setVisible(true);
	}
	
	/**
	 * Loads obj file
	 * 
	 * @param path the path to the file
	 */
	public static void loadModel(String path){
		try {
			obj3D = new Load3D(path);
			faces = obj3D.getFaces();
			vertices = obj3D.getVertices();
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
			System.exit(0);
		}
		System.out.println("Model loaded: triangles-"+faces.size()+
				" vertices-"+vertices.size());
		System.out.println(PRINT_SEP);
	}
	
	/**
	 * Correct the normal direction for every face to point towards
	 * the otter of the object
	 * 
	 */
	public static void correctFacesNormal(){
		System.out.println("Faces normals orientation checking");
		
		for(Triangle t: faces){
			Vector3D normal = t.getNormalVector();
			Point3D from = new Point3D(
							t.getCenter().getX()+normal.getX(),
							t.getCenter().getY()+normal.getY(),
							t.getCenter().getZ()+normal.getZ());
			
			Ray ray = new Ray(from, normal);
			double[] distance = new double[1];
			int intersections = 0;
			
			for(Triangle triangleTest: faces){
				if(ray.isRayTriangleIntersecting(triangleTest, distance)){
					intersections++;
				}
			}
			
			if(!(intersections%2==0)){
				System.out.println("Direciton changed");
				t.setNormal(t.getNormalVector().times(-1));
			}else{
				System.out.println("Direciton preserved");
			}
		}
		System.out.println(PRINT_SEP);
	}
	
	/**
	 * Skeleton extraction
	 */
	public static void skeletonExtraction(){
		SkeletonExtraction skeletonExtraction = new SkeletonExtraction(faces, PUSHING_FACTOR,
				ITERATIONS, STEP);
		
		long start = System.currentTimeMillis();    
		skeletonExtraction.getVDS(vertices);
		long elapsedTime = System.currentTimeMillis() - start;
		System.out.println("Skeleton extraction duration: "+elapsedTime+"ms");
		
		chains = skeletonExtraction.getChain();
		System.out.println("Skeleton chains: "+chains.size());
		System.out.println(PRINT_SEP);
	}
	
	/**
	 * Skeleton refinement
	 */
	public static void refineSkeleton(){
		System.out.println("Skeleton refining");
		
		SkeletonRefine skeletonRefine = new SkeletonRefine(chains, SAMPLING,
				DISTANCE_TOLERANCE, MERGE_TOLERANCE, CHAIN_SIZE_TOLERANCE);
		
		skeletonRefine.beginRefinement();
		chains = skeletonRefine.getChains();
		System.out.println(PRINT_SEP);
	}
	
	/**
	 * Generates skeleton hierarchy bone system
	 */
	public static void generateSkeletonSystem(){
		System.out.println("Skeleton system generation");
		
		SkeletonSystemGeneration skeletonSystem = new SkeletonSystemGeneration(chains);
		skeletonSystem.beginGeneration();
		
		root = skeletonSystem.getRoot();
		System.out.println(PRINT_SEP);
	}
	
	/**
	 * Prints the animation key info
	 */
	public static void printAnimationKeyInfo(){
		System.out.println("Animation keys");
		System.out.println("N: next button");
		System.out.println("R: record key frame");
		System.out.println("Up: increase angle of selected bone");
		System.out.println("Down: decrease angle of selected bone");
		System.out.println("A: start/stop animation");
		System.out.println(PRINT_SEP);
	}

}
